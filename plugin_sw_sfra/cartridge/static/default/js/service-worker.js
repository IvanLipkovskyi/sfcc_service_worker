/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./cartridges/plugin_sw_sfra/cartridge/client/default/js/service-worker.js":
/*!*********************************************************************************!*\
  !*** ./cartridges/plugin_sw_sfra/cartridge/client/default/js/service-worker.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sw_helpers_streamHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sw/helpers/streamHelper */ \"./cartridges/plugin_sw_sfra/cartridge/client/default/js/sw/helpers/streamHelper.js\");\n/**\n * Main service worker script.\n *\n * This service worker handles:\n * - Caching AJAX responses and page fragments defined in configuration.\n * - Showing an offline page when the network is unavailable.\n * - Caching static assets such as images, fonts, JS, and CSS.\n * - Cache cleanup using URL triggers.\n * - Fast updates using skipWaiting and clients.claim.\n * - Basic auth fallback support for browser issues (e.g., Chrome bug).\n */\n\n\n\n// These values are injected at build time\nself.buildSuitePreparedData = {\n    codeVersion: `Build-${new Date().getTime()}` \n};\n// Generate cache name as code version + BE cache version. We need it to properly invalidate it on each build or Demandware cache reset.\nconst CACHE_ID = self.buildSuitePreparedData.codeVersion + '_' + self.serverPreparedData.cacheVersion;\nconst OFFLINE_URL = self.serverPreparedData.offlineUrl;\n\n/**\n * Create a lookup table for URLs that trigger cache invalidation.\n * @returns {Object} Map of URL to cache suffix list.\n */\nfunction generateCacheInvalidationMap() {\n    const map = {};\n    for (const part of self.serverPreparedData.cachedParts) {\n        for (const url of part.cacheCleanTriggerUrls) {\n            map[url] = map[url] || [];\n            map[url].push(part.cacheSuffix);\n        }\n    }\n    for (const urlConfig of self.serverPreparedData.cachedUrls) {\n        for (const url of urlConfig.cacheCleanTriggerUrls) {\n            map[url] = map[url] || [];\n            map[url].push(urlConfig.cacheSuffix);\n        }\n    }\n    return map;\n}\n\nself.cacheCleanUrls = generateCacheInvalidationMap();\n\n/**\n * Determines whether the given URL points to a resource located in the Library or Static folders.\n * This helps identify which resources should be cached or intercepted by the service worker.\n * @param {string} url - The resource URL to evaluate.\n * @returns {boolean} - True if the URL belongs to Library or Static folders; otherwise, false.\n */\nfunction isStaticResource(url) {\n    return /\\/demandware.static\\//.test(url) && !/\\/demandware.static\\/-\\/Sites-[^/]+/.test(url);\n}\n\n/**\n * Verifies whether the resource has an allowed file extension.\n * This check is necessary because some requests might not include a valid \"destination\" attribute.\n * @param {string} url - The resource URL to check.\n * @returns {boolean} - True if the URL matches one of the allowed file extensions; otherwise, false.\n */\nfunction isAllowedExtension(url) {\n    return /.*\\.(js|css)/.test(url);\n}\n\n/**\n * Determines whether a given request should be cached based on its type.\n * Checks if the request corresponds to a cacheable file type (e.g., scripts, styles, fonts, images).\n * @param {Request} request - The FetchEvent request object.\n * @returns {boolean} - True if the file is eligible for caching; otherwise, false.\n */\nfunction isCacheableStatic(request) {\n    var a = isStaticResource(request.url);\n    if (isStaticResource(request.url)) {\n        var b =\n            ['image', 'script', 'style', 'font'].indexOf(request.destination) !== -1 ||\n            isAllowedExtension(request.url);\n\n        return b;\n    }\n    return false;\n}\n\n/**\n * Add skip parameters to fetch request to exclude cached page parts.\n * @param {Request} originalRequest \n * @returns {Request} New request with skip parameters.\n */\nasync function addSkipParamsToRequest(originalRequest) {\n    const url = new URL(originalRequest.url);\n    for (const part of self.serverPreparedData.cachedParts || []) {\n        if (part.skipParameter) {\n            url.searchParams.append(part.skipParameter, 'true');\n        }\n    }\n    const init = {\n        cache: originalRequest.cache,\n        credentials: originalRequest.credentials,\n        headers: originalRequest.headers,\n        method: originalRequest.method,\n        referrer: originalRequest.referrer,\n        redirect: 'manual'\n    };\n    const buffer = await originalRequest.arrayBuffer();\n    if (buffer && buffer.byteLength > 0) {\n        init.body = buffer;\n    }\n    return new Request(url, init);\n}\n\n/**\n * Find cache config for AJAX request.\n * @param {FetchEvent} event \n * @returns {Object|boolean}\n */\nfunction getAjaxCacheConfig(event) {\n\n    var vals= [];\n\n    for (let [key, value] of event.request.headers.entries()) {\n        vals.push(`${key}: ${value}`);\n    }\n    const siteId = event.request.headers.get(_sw_helpers_streamHelper__WEBPACK_IMPORTED_MODULE_0__.X_SF_CC_SITEID);\n    const locale = event.request.headers.get(_sw_helpers_streamHelper__WEBPACK_IMPORTED_MODULE_0__.X_SF_CC_REQUESTLOCALE);\n    if (!siteId || !locale) return false;\n\n    return self.serverPreparedData.cachedUrls.find(cfg => {\n        let expectedUrl = cfg.url\n            .replace(`-${self.serverPreparedData.urlSiteId}-`, `-${siteId}-`)\n            .replace(`/${self.serverPreparedData.urlLocale}/`, `/${locale}/`);\n\n        return event.request.url.indexOf(expectedUrl) !== -1;\n    });\n}\n\n/**\n * Returns an HTML/JavaScript response that unregisters all active service workers and reloads the page.\n * This workaround addresses a Chrome bug that prevents the Basic Authentication prompt from displaying\n * when a request is intercepted by a service worker.\n * See: https://bugs.chromium.org/p/chromium/issues/detail?id=1055253\n * @returns {Response} - An HTML response with a script to unregister service workers and reload the page.\n */\nfunction getBasicAuthFallbackResponse() {\n    return new Response(`\n        <html><head><script>\n            navigator.serviceWorker.getRegistrations().then(regs => Promise.all(regs.map(r => r.unregister()))).then(() => {\n                window.location.reload();\n            });\n        </script></head><body></body></html>\n    `, {\n        headers: new Headers({ 'Content-Type': 'text/html' })\n    });\n}\n\nfunction isSameOrigin(url) {\n  return new URL(url, self.location).origin === self.location.origin;\n}\n\n/**\n * Asynchronously deletes all outdated caches within the current service worker scope.\n * This ensures only the active cache version is kept and used by the service worker.\n * @returns {Promise} - A promise that resolves once all old cache entries have been removed.\n */\nasync function clearOldCaches() {\n    const names = await caches.keys();\n    return Promise.all(names.filter(name => name !== CACHE_ID).map(n => caches.delete(n)));\n}\n\n/**\n * Disables the Navigation Preload feature for the service worker.\n * This is necessary because preloading fetches the original URL before we can append custom parameters,\n * which can result in unnecessary or duplicate network requests.\n * For reference: https://developers.google.com/web/updates/2017/02/navigation-preload\n * @returns {void}\n */\nasync function disableNavigationPreload() {\n    if ('navigationPreload' in self.registration) {\n        await self.registration.navigationPreload.disable();\n    }\n}\n\n/**\n * Caches the offline fallback page during service worker installation.\n * The `{ cache: 'reload' }` option ensures the page is fetched directly from the network,\n * bypassing any existing HTTP cache.\n * @returns {void}\n */\nasync function precacheOfflinePage() {\n    const cache = await caches.open(CACHE_ID);\n    await cache.add(new Request(OFFLINE_URL, { cache: 'reload' }));\n}\n\n/**\n * Compares the current request URL (from the fetch event) against a list of predefined cache-cleaning trigger URLs.\n * Each cache key follows the pattern: SiteId.Locale.Suffix. When a match is found, the corresponding cache entries are cleared\n * for all Site IDs and locales.\n * @param {FetchEvent} fetchEvent - The fetch event containing the request to check.\n * @returns {object} - An object representing key-value pairs used for cache cleanup.\n */\nasync function cleanTriggeredCache(fetchEvent) {    \n    const shortUrl = fetchEvent.request.url.replace(/(Sites-[\\w\\-_]+-Site\\/[\\w]{2,7}\\/)/, '');\n    const trigger = Object.keys(self.cacheCleanUrls).find(u => shortUrl.indexOf(u) !== -1);\n    const suffixes = self.cacheCleanUrls[trigger] || [];\n    const cache = await caches.open(CACHE_ID);\n    const keys = await cache.keys();\n\n    const toDelete = keys.filter(entry => suffixes.some(s => entry.url.indexOf('.' + s) !== -1));\n    await Promise.all(toDelete.map(k => cache.delete(k)));\n}\n\n/**\n * Handles all navigation requests by constructing a new Response object that combines\n * the network response with cached partial content (e.g., header/footer).\n * Site ID and locale are extracted from response headers and used to determine cache keys.\n * The required cache parts and placeholders are defined in `serviceWorkerConfig.js` and inserted during runtime.\n * If the network is unavailable, the pre-cached offline page is returned instead.\n * Note: A `fetch()` response with a 4xx or 5xx status will not trigger a `catch()` block.\n * See more:\n * [Offline fallback](https://web.dev/offline-fallback-page/)\n * [Offline page example](https://serviceworke.rs/offline-fallback_service-worker_doc.html)\n * @param {FetchEvent} fetchEvent - The fetch event for a navigation request.\n * @returns {Response} - A complete HTML response from either the network or offline cache.\n */\nasync function respondToNavigation(fetchEvent) {    \n    try {\n        await cleanTriggeredCache(fetchEvent);\n        const modifiedRequest = await addSkipParamsToRequest(fetchEvent.request);\n        let networkResponse = await fetch(modifiedRequest);\n\n        if (networkResponse.status === 401) return getBasicAuthFallbackResponse();\n        if ([301, 302].indexOf(networkResponse.status) !== -1 || networkResponse.type === 'opaqueredirect') return networkResponse;\n\n        return (0,_sw_helpers_streamHelper__WEBPACK_IMPORTED_MODULE_0__.createStream)(networkResponse, self.serverPreparedData.cachedParts, CACHE_ID);\n    } catch (err) {\n        const cache = await caches.open(CACHE_ID);\n        return await cache.match(OFFLINE_URL);\n    }\n}\n\n/**\n * Handles \"same-origin\" fetch requests by returning either a cached response or fetching from the network.\n * If the request matches a configured cache rule, the service worker attempts to retrieve it from the cache.\n * If not found, it fetches the response from the network, caches it for future use, and then returns it.\n * @param {FetchEvent} fetchEvent - The fetch event for an AJAX or API request.\n * @param {object} config - Configuration object specifying how to cache the request.\n * @returns {Response} - The response retrieved from the cache or the network.\n */\nasync function respondToAjax(fetchEvent, config) {\n    if (config) {\n        const cache = await caches.open(CACHE_ID);\n        const siteId = fetchEvent.request.headers.get(_sw_helpers_streamHelper__WEBPACK_IMPORTED_MODULE_0__.X_SF_CC_SITEID);\n        const locale = fetchEvent.request.headers.get(_sw_helpers_streamHelper__WEBPACK_IMPORTED_MODULE_0__.X_SF_CC_REQUESTLOCALE);\n        const key = siteId + '.' + locale + '.' + config.cacheSuffix;\n        let cached = await cache.match(key);\n\n        if (cached) return cached;\n\n        cached = await fetch(fetchEvent.request);\n\n        if (cached && cached.ok) {\n            fetchEvent.waitUntil(cache.put(key, cached.clone()));\n        }\n        \n        return cached;\n    }\n\n    return fetch(fetchEvent.request);\n}\n\n/**\n * Handles fetch requests for static resources (e.g., images, scripts, styles).\n * Tries to return the resource from cache first. If not available, fetches it from the network,\n * stores it in the cache for future use, and returns the network response.\n * For more on caching strategies, see:\n * [Caching files](https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker),\n * [Network or cache](https://serviceworke.rs/strategy-network-or-cache.html)\n * @param {Request} request - The fetch event's request object for a static resource.\n * @returns {Response} - Cached or network response for the requested resource.\n */\nasync function respondToStatic(request) {\n    const cache = await caches.open(CACHE_ID);\n    const cached = await cache.match(request);\n    if (cached) return cached;\n    const network = await fetch(request);\n\n    if (network && network.ok) {\n        cache.put(request, network.clone());\n    }\n    return network;\n}\n\nself.addEventListener('install', (event) => {\n    // Kill-switch moved here â€” works reliably\n    if (self.serverPreparedData?.swEnabled === false) {\n        event.waitUntil(\n            (async () => {\n                // Clear all caches\n                clearOldCaches()\n\n                // Unregister SW\n                await self.registration.unregister();\n\n                // Reload all tabs\n                const clients = await self.clients.matchAll();\n                for (const client of clients) {\n                    client.navigate(client.url);\n                }\n            })()\n        );\n        return; // Stop further activation\n    } else {\n        event.waitUntil(precacheOfflinePage());\n        self.skipWaiting();\n    }\n});\n\nself.addEventListener('activate', (event) => {\n    const sendPostMessage = messageStr => self.clients.matchAll()\n        .then(clientList => clientList.forEach(client =>\n            client.postMessage({ message: messageStr })));\n\n    event.waitUntil(sendPostMessage(CACHE_ID));\n\n    event.waitUntil(disableNavigationPreload());\n    clearOldCaches();\n    self.clients.claim();\n});\n\nself.addEventListener('fetch', (event) => {\n    const request = event.request;\n    const ajaxConfig = getAjaxCacheConfig(event);\n\n    if (isSameOrigin(request.url) && ajaxConfig) {\n        event.respondWith(respondToAjax(event, ajaxConfig));\n    } else if (request.mode === 'same-origin') {\n        event.waitUntil(cleanTriggeredCache(event));\n    } else if (request.mode === 'navigate') {\n        event.respondWith(respondToNavigation(event));\n    } else if (isCacheableStatic(request)) {\n        event.respondWith(respondToStatic(request));\n    }\n});\n\n\n//# sourceURL=webpack://sfra/./cartridges/plugin_sw_sfra/cartridge/client/default/js/service-worker.js?");

/***/ }),

/***/ "./cartridges/plugin_sw_sfra/cartridge/client/default/js/sw/helpers/streamHelper.js":
/*!******************************************************************************************!*\
  !*** ./cartridges/plugin_sw_sfra/cartridge/client/default/js/sw/helpers/streamHelper.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   X_SF_CC_REQUESTLOCALE: function() { return /* binding */ X_SF_CC_REQUESTLOCALE; },\n/* harmony export */   X_SF_CC_SITEID: function() { return /* binding */ X_SF_CC_SITEID; },\n/* harmony export */   createStream: function() { return /* binding */ createStream; }\n/* harmony export */ });\n/* eslint-disable no-restricted-globals */\nconst PLACEHOLDER_PREFIX = '$sw';\nconst LAST_BYTES_COUNT = 20; // Max placeholder length assumed\n\nconst X_SF_CC_SITEID = 'x-sf-cc-siteid';\nconst X_SF_CC_REQUESTLOCALE = 'x-sf-cc-requestlocale';\n\n/**\n * Streams byte array to detect if any placeholders match at a specific index.\n * Evaluates each placeholder byte-by-byte. Non-matching candidates are excluded.\n * Returns the matched placeholder config with its start/end positions, or null.\n * @param {Uint8Array} bytes - The byte array to search.\n * @param {number} startIndex - The index to start scanning from.\n * @param {Uint8Array} prefixBytes - The byte representation of the '$sw' prefix.\n * @param {Array} placeholderConfigs - List of available placeholder configurations.\n * @returns {object|null} The matching placeholder config with position data, or null.\n */\nfunction findMatchingPlaceholder(bytes, startIndex, prefixBytes, placeholderConfigs) {\n    const len = bytes.length;\n    let i = startIndex;\n    let idx = 0;\n    let allFinished = false;\n    let found = false;\n    let matchData = null;\n\n    const candidates = placeholderConfigs.map(config => ({\n        config,\n        bytes: config.placeholderBytes,\n        length: config.placeholderBytes.length,\n        matched: config.placeholderBytes[0] === bytes[i],\n        finished: config.placeholderBytes.length === 1\n    }));\n\n    i++;\n    idx++;\n\n    while (i < len && candidates.length && !allFinished && !found) {\n        allFinished = true;\n\n        for (let k = candidates.length - 1; k >= 0; k--) {\n            const c = candidates[k];\n            if (idx < c.length) {\n                c.matched = c.matched && c.bytes[idx] === bytes[i];\n            }\n            if (idx === c.length - 1) {\n                c.finished = true;\n            }\n\n            allFinished = allFinished && c.finished;\n            found = found || (c.finished && c.matched);\n\n            if (!c.matched) {\n                candidates.splice(k, 1);\n            }\n        }\n\n        i++;\n        idx++;\n    }\n\n    if (found) {\n        matchData = candidates[0];\n        matchData.end = i - 1;\n        matchData.start = matchData.end - matchData.length - prefixBytes.length + 1;\n    }\n\n    return matchData;\n}\n\n/**\n * Searches through a byte chunk for placeholders.\n *\n * If found, splits the chunk into:\n *   - before placeholder\n *   - after placeholder\n *   - leftover bytes to handle boundary cases\n *\n * Preserves last bytes if not final chunk to catch split placeholders.\n * @param {Uint8Array} bytes - Byte array to search through.\n * @param {Uint8Array} prefixBytes - Byte sequence of the placeholder prefix (e.g., '$sw').\n * @param {Array} placeholderConfigs - List of placeholder configurations with encoded byte values.\n * @param {boolean} isFinal - Whether this is the final chunk; affects handling of leftover bytes.\n * @returns {object} Object containing:\n *   - found (object|null),\n *   - before (Uint8Array|null),\n *   - after (Uint8Array|null),\n *   - leftover (Uint8Array|null).\n */\nfunction extractPlaceholderChunk(bytes, prefixBytes, placeholderConfigs, isFinal) {\n    const len = bytes.length;\n    let pointer = 0;\n    let prefixIdx = 0;\n    let found = null;\n    let before = bytes;\n    let after = null;\n    let leftover = null;\n\n    while (pointer < len && !found) {\n        while (\n            bytes[pointer] === prefixBytes[prefixIdx] &&\n            prefixIdx < prefixBytes.length &&\n            pointer < len\n            ) {\n                prefixIdx++;\n                pointer++;\n            }\n\n        if (prefixIdx === prefixBytes.length && pointer < len) {\n            found = findMatchingPlaceholder(bytes, pointer, prefixBytes, placeholderConfigs);\n        }\n\n        prefixIdx = 0;\n        pointer++;\n    }\n\n    if (found) {\n        before = bytes.slice(0, found.start);\n        after = bytes.slice(found.end + 1);\n    } else if (!isFinal) {\n        if (before.length > LAST_BYTES_COUNT) {\n            leftover = before.slice(before.length - LAST_BYTES_COUNT);\n            before = before.slice(0, before.length - LAST_BYTES_COUNT);\n        } else {\n            leftover = before;\n            before = null;\n        }\n    }\n\n    return { found, before, after, leftover };\n}\n\n/**\n * Encodes placeholders from config into byte sequences for stream matching.\n * @param {Array} cachedParts - The original placeholder configuration passed to the service worker.\n * @returns {object} An object containing:\n *   - `prefixBytes`: Byte representation of the placeholder prefix.\n *   - `configs `: Array of placeholder configurations with encoded byte values.\n */\nfunction encodePlaceholderConfigs(cachedParts) {\n    const encoder = new TextEncoder();\n    const prefixBytes = encoder.encode(PLACEHOLDER_PREFIX);\n    const configs = cachedParts.map(c => {\n        if (!c.placeholder.startsWith(PLACEHOLDER_PREFIX)) {\n            throw new Error(`Each placeholder must start with ${PLACEHOLDER_PREFIX}`);\n        }\n\n        return { ...c, placeholderBytes: encoder.encode(c.placeholder.slice(PLACEHOLDER_PREFIX.length)) };\n    });\n\n    return { prefixBytes, configs };\n}\n\n/**\n * Builds initialization headers and metadata from the original Response.\n * @param {Response} fromResponse - The original response object.\n * @returns {object} An object suitable for use with the `Response` constructor.\n */\nfunction buildInitHeaders(fromResponse) {\n    const init = {\n        status: fromResponse.status,\n        statusText: fromResponse.statusText,\n        headers: { 'X-ServedByServiceWorker': 'true' }\n    };\n    fromResponse.headers.forEach((v, k) => (init.headers[k] = v));\n    \n    return init;\n}\n\n/**\n * Retrieves or fetches and caches a response fragment based on cache rules.\n * @param {object} partConfig - Configuration for the specific cacheable part.\n * @param {string} siteId - The current site identifier.\n * @param {string} locale - The current request locale.\n * @param {string} cacheId - The name of the cache storage to use.\n * @returns {object} An object containing `value`, a Uint8Array of the cached content.\n */\nasync function fetchOrCachePart(partConfig, siteId, locale, cacheId) {\n    const key = `${siteId}.${locale}.${partConfig.cacheSuffix}`;\n    let resp = await caches.match(key);\n\n    if (!resp) {\n        let url = partConfig.url\n            .replace(`-${self.serverPreparedData.urlSiteId}-`, `-${siteId}-`)\n            .replace(`/${self.serverPreparedData.urlLocale}/`, `/${locale}/`);\n\n        resp = await fetch(new Request(url));\n        if (resp && resp.ok) {\n            const cache = await caches.open(cacheId);\n            await cache.put(key, resp.clone());\n        }\n    }\n\n    const data = new Uint8Array(await resp.arrayBuffer());\n    \n    return { value: data };\n}\n\n/**\n * Merges several Uint8Array chunks into a single array.\n * @param {...Uint8Array} arrays - The byte arrays to merge.\n * @returns {Uint8Array} A new Uint8Array containing all bytes from the input arrays.\n */\nfunction combineUint8Arrays(...arrays) {\n    let total = arrays.reduce((sum, arr) => sum + arr.length, 0);\n    const result = new Uint8Array(total);\n    let offset = 0;\n\n    for (let arr of arrays) {\n        result.set(arr, offset);\n        offset += arr.length;\n    }\n\n    return result;\n}\n\n/**\n * Creates a streaming Response that replaces placeholders on-the-fly using cached or fetched parts.\n * Reads the base response as a stream and searches for configured placeholders.\n * When found, these placeholders are replaced on-the-fly using content fetched from cache (or network).\n * @param {Response} baseResponse - The original server response to process.\n * @param {Array} cachedParts - Configuration objects for placeholder replacements.\n * @param {string} cacheId - Cache storage name used to retrieve or store parts.\n * @returns {Response} A new Response instance with streaming content.\n */\nfunction createStream(baseResponse, cachedParts, cacheId) {\n    const headersInit = buildInitHeaders(baseResponse);\n    const siteId = headersInit.headers[X_SF_CC_SITEID];\n    const locale = headersInit.headers[X_SF_CC_REQUESTLOCALE];\n\n    const stream = new ReadableStream({\n        async start(controller) {\n            this.reader = baseResponse.body.getReader();\n            const { prefixBytes, configs } = encodePlaceholderConfigs(cachedParts);\n            this.prefixBytes = prefixBytes;\n            this.configs = configs;\n            this.queue = [this.readChunk()];\n        },\n        async readChunk() {\n            const res = await this.reader.read();\n            \n            return { ...res, isBase: true };\n        },\n        async nextFromQueue() {\n            let item = await this.queue.shift();\n            while (item.merge && this.queue.length) {\n                const next = await this.queue.shift();\n                item.done = item.done || next.done;\n                item.merge = next.merge;\n                item.isBase = next.isBase;\n                \n                if (next.value) {\n                    item.value = combineUint8Arrays(item.value || [], next.value);\n                }\n            }\n            \n            return item;\n        },\n        async pull(controller) {\n            if (!this.queue.length || this.done) return controller.close();\n\n            const { done, value, isBase } = await this.nextFromQueue();\n            this.done = this.done || done;\n            if (this.done && !value) return controller.close();\n\n            const { found, before, after, leftover } = extractPlaceholderChunk(\n                value, this.prefixBytes, this.configs, this.done\n            );\n\n            if (before) controller.enqueue(before);\n            if (leftover) this.queue.unshift(Promise.resolve({ value: leftover, merge: true }));\n            if (after) this.queue.unshift(Promise.resolve({ value: after, merge: false }));\n            if (found) this.queue.unshift(fetchOrCachePart(found.config, siteId, locale, cacheId));\n            if (!this.done && isBase) this.queue.push(this.readChunk());\n\n            return this.pull(controller);\n        },\n        cancel() {\n            this.done = true;\n            this.queue = [];\n        }\n    });\n\n    return new Response(stream, headersInit);\n}\n\n\n//# sourceURL=webpack://sfra/./cartridges/plugin_sw_sfra/cartridge/client/default/js/sw/helpers/streamHelper.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./cartridges/plugin_sw_sfra/cartridge/client/default/js/service-worker.js");
/******/ 	
/******/ })()
;